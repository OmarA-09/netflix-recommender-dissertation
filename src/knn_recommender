import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.neighbors import NearestNeighbors
from src.integration_service import NetflixRecommenderIntegration
import logging

class KNNNetflixRecommender:
    def __init__(self, profile_path="user_profile_knn.pkl", n_neighbours=10):
        """Initialise the KNN-based Netflix recommender system"""
        self.integration_service = NetflixRecommenderIntegration(profile_path)
        
        self.df = None
        self.tfidf_matrix = None
        self.knn_model = None
        self.n_neighbours = n_neighbours
        self.user_liked_titles = set()
        self.user_disliked_titles = set()
        self.user_profile = None
        self.profile_path = profile_path
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def load_data(self, filepath):
        """Load the Netflix dataset"""
        self.df = pd.read_csv(filepath)
        self.df = self.integration_service.preprocess_dataset(self.df)
        
        self.logger.info(f"Loaded dataset with {self.df.shape[0]} titles")
        
        # Load existing user profile
        profile_data = self.integration_service.load_user_profile()
        if profile_data:
            self.user_liked_titles = profile_data['liked_titles']
            self.user_disliked_titles = profile_data['disliked_titles']
            self.user_profile = profile_data['user_profile']
        
        return self
    
    def preprocess(self):
        """Create the TF-IDF matrix and fit KNN model"""
        self.logger.info("Building TF-IDF matrix...")
        tfidf = TfidfVectorizer(stop_words='english')
        self.tfidf_matrix = tfidf.fit_transform(self.df['combined_features'])
        
        self.logger.info(f"Created TF-IDF matrix with shape: {self.tfidf_matrix.shape}")
        
        # Fit KNN model on the TF-IDF matrix
        self.logger.info(f"Fitting KNN model with {self.n_neighbours} neighbours...")
        self.knn_model = NearestNeighbors(
            n_neighbors=min(self.n_neighbours + 1, self.tfidf_matrix.shape[0]),
            algorithm='auto',
            metric='euclidean'
        )
        self.knn_model.fit(self.tfidf_matrix)
        
        # Initialize user profile if not already loaded
        if self.user_profile is None:
            self.user_profile = np.zeros(self.tfidf_matrix.shape[1])
            
        return self
    
    def update_user_profile(self):
        """Update user profile based on liked and disliked titles"""
        if not self.user_liked_titles and not self.user_disliked_titles:
            self.logger.warning("No liked or disliked titles to build profile from")
            return
        
        # Get indices of liked and disliked titles
        liked_indices = []
        for title in self.user_liked_titles:
            matches = self.df[self.df['title'] == title]
            if not matches.empty:
                liked_indices.append(matches.index[0])
        
        disliked_indices = []
        for title in self.user_disliked_titles:
            matches = self.df[self.df['title'] == title]
            if not matches.empty:
                disliked_indices.append(matches.index[0])
        
        # Update user profile based on liked and disliked content
        if liked_indices:
            liked_profile = np.mean(self.tfidf_matrix[liked_indices].toarray(), axis=0)
        else:
            liked_profile = np.zeros(self.tfidf_matrix.shape[1])
            
        if disliked_indices:
            disliked_profile = np.mean(self.tfidf_matrix[disliked_indices].toarray(), axis=0)
            # Subtract disliked profile with lower weight (0.5)
            self.user_profile = liked_profile - 0.5 * disliked_profile
        else:
            self.user_profile = liked_profile
            
        # Normalize profile
        profile_norm = np.linalg.norm(self.user_profile)
        if profile_norm > 0:
            self.user_profile = self.user_profile / profile_norm
            
        # Save profile using integration service
        self.integration_service.save_user_profile(
            self.user_liked_titles, 
            self.user_disliked_titles, 
            self.user_profile
        )
        
        self.logger.info("User profile updated based on preferences")
    
    def like_title(self, title):
        """User likes a title"""
        matches = self.df[self.df['title'] == title]
        if matches.empty:
            self.logger.warning(f"Title not found: {title}")
            return False
        
        title_info = matches.iloc[0]
        self.logger.info(f"You liked: {title_info['title']} ({title_info['type']}, {title_info['rating']})")
        
        # Add to liked set and remove from disliked if present
        self.user_liked_titles.add(title)
        self.user_disliked_titles.discard(title)
        
        # Update user profile
        self.update_user_profile()
        return True
    
    def dislike_title(self, title):
        """User dislikes a title"""
        matches = self.df[self.df['title'] == title]
        if matches.empty:
            self.logger.warning(f"Title not found: {title}")
            return False
        
        title_info = matches.iloc[0]
        self.logger.info(f"You disliked: {title_info['title']} ({title_info['type']}, {title_info['rating']})")
        
        # Add to disliked set and remove from liked if present
        self.user_disliked_titles.add(title)
        self.user_liked_titles.discard(title)
        
        # Update user profile
        self.update_user_profile()
        return True
        
    def get_recommendations(self, top_n=10, rating_filter=None):
        """Get personalised recommendations based on user profile and KNN"""
        if self.user_profile is None or len(self.user_liked_titles) == 0:
            self.logger.warning("Not enough preference data")
            return pd.DataFrame()
        
        # Use the user profile as a query point
        user_profile_matrix = self.user_profile.reshape(1, -1)
        
        # Find nearest neighbours to the user profile
        distances, indices = self.knn_model.kneighbors(user_profile_matrix, n_neighbors=min(50, self.tfidf_matrix.shape[0]))
        
        # Create a list of (index, score) tuples
        # Convert distance to similarity score (1 - normalized distance)
        max_distance = distances.max()
        if max_distance > 0:
            similarities = 1 - (distances[0] / max_distance)
        else:
            similarities = np.ones_like(distances[0])
        
        scored_items = list(zip(indices[0], similarities))
        
        # Use integration service to filter recommendations
        all_interacted = self.user_liked_titles.union(self.user_disliked_titles)
        recommendation_indices = self.integration_service.filter_recommendations(
            self.df, scored_items, all_interacted, rating_filter, top_n
        )
        
        if not recommendation_indices:
            self.logger.warning("No suitable recommendations found")
            return pd.DataFrame()
        
        # Format recommendations as DataFrame
        rec_indices = [idx for idx, _ in recommendation_indices]
        rec_scores = [score for _, score in recommendation_indices]
        
        recommendations = self.df.iloc[rec_indices][
            ['title', 'type', 'rating', 'release_year', 'description']
        ].copy()
        
        recommendations['similarity_score'] = rec_scores
        recommendations['rank'] = range(1, len(recommendations) + 1)
        
        return recommendations
    
    def get_similar_titles(self, title, n=10):
        """Get titles similar to a given title using KNN"""
        matches = self.df[self.df['title'] == title]
        if matches.empty:
            self.logger.warning(f"Title not found: {title}")
            return pd.DataFrame()
        
        title_idx = matches.index[0]
        title_features = self.tfidf_matrix[title_idx].reshape(1, -1)
        
        # Find nearest neighbours to the title
        distances, indices = self.knn_model.kneighbors(title_features, n_neighbors=n+1)
        
        # The first result will be the title itself, so we skip it
        similar_indices = indices[0][1:]
        similarity_scores = 1 - (distances[0][1:] / distances[0][1:].max())
        
        similar_titles = self.df.iloc[similar_indices][
            ['title', 'type', 'rating', 'release_year', 'description']
        ].copy()
        
        similar_titles['similarity_score'] = similarity_scores
        similar_titles['rank'] = range(1, len(similar_titles) + 1)
        
        return similar_titles
    
    def get_user_preferences(self):
        """Get information about user's current preferences"""
        liked_df = self.df[self.df['title'].isin(self.user_liked_titles)]
        disliked_df = self.df[self.df['title'].isin(self.user_disliked_titles)]
        
        self.logger.info(f"You have liked {len(liked_df)} titles and disliked {len(disliked_df)} titles.")
        
        # Use integration service for preference analysis
        preference_analysis = self.integration_service.analyze_user_preferences(liked_df)
        
        if preference_analysis:
            self.logger.info("\n--- Your Favorite Genres ---")
            for genre, count in preference_analysis['favorite_genres'].items():
                self.logger.info(f"â€¢ {genre} ({count} titles)")
        
        return liked_df, disliked_df
    
    def reset_preferences(self):
        """Reset all user preferences"""
        self.user_liked_titles = set()
        self.user_disliked_titles = set()
        self.user_profile = np.zeros(self.tfidf_matrix.shape[1])
        
        # Use integration service to reset profile
        self.integration_service.reset_preferences()
        
        self.logger.info("User preferences have been reset.")